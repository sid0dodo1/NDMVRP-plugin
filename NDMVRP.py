# -*- coding: utf-8 -*-
"""
/***************************************************************************
 NDMVRP
                                 A QGIS plugin
 this plugin creates VRP strategies for NDM
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-06-14
        git sha              : $Format:%H$
        copyright            : (C) 2023 by AEM
        email                : sid.mpadhyay@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QDialog, QTableWidgetItem, QDialog, QVBoxLayout, QLineEdit, QPushButton, QLabel, QFormLayout, QFileDialog, QTableWidget

from qgis.core import QgsField, QgsFields, QgsVectorLayer, QgsWkbTypes, QgsProject
from PyQt5.QtCore import QVariant
from qgis.core import QgsField, QgsFields, QgsVectorLayer, QgsWkbTypes, QgsProject, QgsCoordinateReferenceSystem
from qgis.core import QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsProject
from qgis.PyQt.QtCore import Qt
from qgis.utils import iface
from qgis.utils import iface
from PyQt5.QtWidgets import QTableWidgetItem, QLineEdit, QMessageBox
from PyQt5.QtWidgets import QMessageBox
import pandas as pd
from qgis.core import QgsVectorLayer, QgsProject, QgsWkbTypes, QgsCoordinateReferenceSystem, QgsField
from qgis.PyQt.QtCore import QVariant
import processing
import sys
from itertools import combinations
# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .NDMVRP_dialog import NDMVRPDialog

import os.path
import shutil
import pandas as pd

from qgis.gui import QgsMapToolEmitPoint

# import algorithm functions
from .shortestpath_algo import shortestpath



#from NDMVRP.io_location import fun
#from .grip_csv import grip
import subprocess
import time

from .datapoints_visualisation import visualize_points
from .datapoints_visualisation_10_final_with_routes_working_and_attributes_complete import datapoints_visualisation_road_layer, get_road_layer_path
from .output_breakdown_for_visualisation_backend_3_final import output_breakdown

# Constants
ADD_DEPOT = 0
ADD_WAREHOUSE = 1
ADD_TRANSHIPMENT = 2
ADD_SIMULTANEOUS_NODES = 3
ADD_RELIEF_CENTER = 4
ADD_SPLIT_NODE = 5

# create mapping for button type and text
button_type_text_mapping = {
    ADD_DEPOT: "Depot",
    ADD_WAREHOUSE: "Warehouse",
    ADD_TRANSHIPMENT: "Transhipment Port",
    ADD_SIMULTANEOUS_NODES: "Simultaneous Nodes",
    ADD_RELIEF_CENTER: "Relief Center",
    ADD_SPLIT_NODE: "Split Node"
}

PICKUP = "Pickup"
DELIVERY = "Delivery"


class MatrixInputDialog(QDialog):
    def __init__(self, vehicle_df, cargo_df):
        super(MatrixInputDialog, self).__init__()

        self.vehicle_df = vehicle_df
        self.cargo_df = cargo_df

        self.layout = QVBoxLayout(self)
        self.setWindowTitle("Vehicle to Load compatibility Information Input")

        # Get column names from cargo_df and set them as headers
        cargo_headers = [str(col) for col in cargo_df['Types']]
        self.rows = len(vehicle_df)
        self.cols = len(cargo_headers) + 2  # Add 1 for the new column

        self.table = QTableWidget(self)
        self.table.setRowCount(self.rows)
        self.table.setColumnCount(self.cols)
        self.table.setHorizontalHeaderLabels(
            ['Vehicle Type'] + cargo_headers + ['Remarks/Comments'])  # Add new header

        # Set row values from vehicle_df['Vehicle Type']
        for row in range(self.rows):
            item = QTableWidgetItem(str(vehicle_df.iloc[row]['Vehicle Type']))
            item.setFlags(item.flags() ^ Qt.ItemIsEditable)
            self.table.setItem(row, 0, item)

        # Set default value as 1 for cargo columns
        for row in range(self.rows):
            for col in range(1, self.cols-1):  # Exclude the last column
                item = QTableWidgetItem("1")
                self.table.setItem(row, col, item)

        self.ok_button = QPushButton('OK', self)
        self.cancel_button = QPushButton('Cancel', self)

        self.layout.addWidget(self.table)
        self.layout.addWidget(self.ok_button)
        self.layout.addWidget(self.cancel_button)

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

    def get_matrix_data(self):
        matrix_data = []

        for row in range(self.rows):
            row_data = []
            for col in range(self.cols):
                item = self.table.item(row, col)
                if item:
                    if (col == 0):
                        row_data.append(str(item.text()))
                    else:
                        row_data.append(float(item.text()))
                else:
                    # Default value is 1 if the cell is empty
                    row_data.append(1.0)
            matrix_data.append(row_data)
        # Convert matrix_data to DataFrame with the first column as index
        matrix_df = pd.DataFrame(matrix_data, columns=['Vehicle Type'] + [str(
            col) for col in self.cargo_df['Types']] + ['Remarks/Comments'])  # Add new column
        # matrix_df.set_index('Vehicle Type', inplace=True)
        return matrix_df


class FormDialogClass(QDialog):
    def __init__(self, fields):
        super(FormDialogClass, self).__init__()

        self.layout = QFormLayout(self)

        # Create line edit fields dynamically based on the fields list
        self.field_widgets = {}
        for field in fields:
            label = QLabel(f'{field}:', self)
            edit_field = QLineEdit(self)
            self.layout.addRow(label, edit_field)
            self.field_widgets[field] = edit_field

        self.ok_button = QPushButton('OK', self)
        self.cancel_button = QPushButton('Cancel', self)

        # Add buttons to the layout
        self.layout.addRow(self.ok_button, self.cancel_button)

        # self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.cancel)

    def get_field_values(self):
        # Method to get the values entered in the fields
        # this code returning multiple values for one input -> solve this
        # print values in field_widgets
        # print(self.field_widgets)
        for field, widget in self.field_widgets.items():
            print(field, widget.text())
        print("------------")
        return {field: widget.text() for field, widget in self.field_widgets.items()}

    # clear the fields
    def clear(self):
        for field, widget in self.field_widgets.items():
            widget.setText("")

    # cancel the dialog
    def cancel(self):
        self.clear()
        self.close()


# $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# Main Plugin Code - NDMVRP
# $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
# $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

class NDMVRP:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'NDMVRP_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&NDMVRP')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

        # ---------- Dialog Code ----------------#
        # Create an instance of FormDialogClass with the new fields list
        self.vehicle_fields = [
            "Vehicle Type", "Description", "Weight Capacity",
            "Volume Capacity", "Vehicle Network Compatibility",
            "Average Speed of Vehicle",
            "Must vehicles of this type finally return to their respective starting depots?", "Remarks/Comments"
            # "Multimodal Compatibility for Air", "Multimodal Compatibility for Water",
            # "Multimodal Compatibility for Rail", "Multimodal Compatibility for Road"
            # "p-value used for generating Test Cases"
        ]
        self.add_vehicle_dialog = FormDialogClass(self.vehicle_fields[1:])
        self.add_vehicle_dialog.ok_button.clicked.connect(
            self.addDataToVehicleTable)
        self.add_vehicle_dialog.setWindowTitle("Vehicle Information Input")

        # Create an instance of FormDialogClass with the new fields list - Pickup / Delivery, Types, Description	Unit Weight	Unit Volume	Remarks / Comments
        # auto add pickup / delivery in table
        self.cargo_fields = [
            "Pickup / Delivery", "Types", "Description", "Unit Weight", "Unit Volume", "Remarks/Comments"
        ]
        self.add_pickup_dialog = FormDialogClass(self.cargo_fields[2:])
        # Method to handle the button click and show the dialog
        self.add_pickup_dialog.ok_button.clicked.connect(
            self.addDataToPickupTable)
        self.add_pickup_dialog.setWindowTitle("Cargo pickup Information Input")

        self.add_delivery_dialog = FormDialogClass(self.cargo_fields[2:])
        # Method to handle the button click and show the dialog
        self.add_delivery_dialog.ok_button.clicked.connect(
            self.addDataToDeliveryTable)
        self.add_delivery_dialog.setWindowTitle(
            "Cargo delivery Information Input")

        # ---------- Depot Details table ----------------#
        self.depot_table_fields = [
            "Sl. No.", "Description", "Latitude", "Longitude", "Multimodal Compatibility for Network_1", "Multimodal Compatibility for Network_2",
            "Multimodal Compatibility for Network_3", "Remarks/Comments"]

        self.depot_table_fields_new = []
        self.vehicle_ids = []
        self.pickup_ids = []
        self.delivery_ids = []

        # ----------- Custom tables  ------------#
        # vehicle table
        self.vehicle_df = pd.DataFrame(columns=self.vehicle_fields)
        # pickup cargo table
        self.cargo_df = pd.DataFrame(columns=self.cargo_fields)
        # matrix table
        self.matrix_df = None

        # ----------- Get lat long  ------------#
        self.get_lat_long_tool = None
        self.location_df = None
        self.location_df_fields = []
        self.latitude = None
        self.longitude = None
        self.button_id_mapping = {}
        self.button_type = None

        # ----------- Depot Layer  ------------#
        self.depot_layer = None
        self.df = None

    # noinspection PyMethodMayBeStatic

    ######### add custom functions for buttons #########

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started

        if self.first_start == True:
            self.first_start = False
            self.dlg = NDMVRPDialog()
            self.dlg.setFixedSize(self.dlg.size())

            # &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
            # -- Buttons click events --#
            #### Upper Buttons ####
            self.dlg.add_vehicle_type_pb.clicked.connect(self.add_vehicle_type)
            self.dlg.add_pickup_cargo_pb.clicked.connect(self.add_pickup_cargo)
            self.dlg.add_delivery_cargo_pb.clicked.connect(
                self.add_delivery_cargo)
            self.dlg.save_vehicle_cargo_data.clicked.connect(
                self.generate_matrix_data)

            #### Lower Buttons ####
            self.canvas = self.iface.mapCanvas()
            if self.get_lat_long_tool is None:
                self.get_lat_long_tool = QgsMapToolEmitPoint(
                    self.canvas)
            # add_depot_pb  add_warehouse_pb    add_transhipment_pb add_simultaneous_nodes_pb   add_relief_center_pb add_split_node_pb
            self.dlg.add_depot_pb.clicked.connect(lambda: self.button_clicked_type(
                ADD_DEPOT))
            self.dlg.add_warehouse_pb.clicked.connect(lambda: self.button_clicked_type(
                ADD_WAREHOUSE))
            self.dlg.add_transhipment_pb.clicked.connect(lambda: self.button_clicked_type(
                ADD_TRANSHIPMENT))
            self.dlg.add_simultaneous_nodes_pb.clicked.connect(
                lambda: self.button_clicked_type(ADD_SIMULTANEOUS_NODES))
            self.dlg.add_relief_center_pb.clicked.connect(
                lambda: self.button_clicked_type(ADD_RELIEF_CENTER))
            self.dlg.add_split_node_pb.clicked.connect(lambda: self.button_clicked_type(
                ADD_SPLIT_NODE))

            # save the depot data
            self.dlg.save_depot_data_pb.clicked.connect(self.save_all_data)
            # clear the location table
            self.dlg.clear_location_table_pb.clicked.connect(
                self.clear_location_table)

            # -------- GENERATE TRAVEL COST TABLES button -----------
            self.dlg.distance_table_pb.clicked.connect(
                self.generate_travel_cost_tables)

            # -------- run vrp button ------------
            self.dlg.run_vrp_pb.clicked.connect(self.run_vrp)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
            pass

    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('NDMVRP', message)

    def add_action(
            self,
            icon_path,
            text,
            callback,
            enabled_flag=True,
            add_to_menu=True,
            add_to_toolbar=True,
            status_tip=None,
            whats_this=None,
            parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/NDMVRP/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'VRP_NDM_2'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&NDMVRP'),
                action)
            self.iface.removeToolBarIcon(action)

    def fill_table(self):
        self.dlg.table.clear()
        depot_id_li = []
        depot_lat_li = []
        depot_lon_li = []
        depot_pickup_li = []
        depot_delivery_li = []
        for feature in self.depot_layer.getFeatures():
            depot_id_li.append(feature['depot_id'])
            depot_lat_li.append(feature['depot_lat'])
            depot_lon_li.append(feature['depot_lon'])
            depot_pickup_li.append(feature['pickup'])
            depot_delivery_li.append(feature['delivery'])

        self.dlg.table.setRowCount(len(depot_id_li))
        for row in range(len(depot_id_li)):
            depot_id = QTableWidgetItem(str(depot_id_li[row]))
            depot_lat = QTableWidgetItem(str(round(depot_lat_li[row], 6)))
            depot_lon = QTableWidgetItem(str(round(depot_lon_li[row], 6)))
            depot_pickup = QTableWidgetItem(str(depot_pickup_li[row]))
            depot_delivery = QTableWidgetItem(str(depot_delivery_li[row]))

            self.dlg.table.setItem(row, 0, depot_id)
            self.dlg.table.setItem(row, 1, depot_lat)
            self.dlg.table.setItem(row, 2, depot_lon)
            self.dlg.table.setItem(row, 3, depot_pickup)
            self.dlg.table.setItem(row, 4, depot_delivery)

        self.df = pd.DataFrame(list(zip(depot_id_li, depot_lat_li, depot_lon_li, depot_pickup_li, depot_delivery_li)),
                               columns=['Depot_ID', 'Depot_latitude', 'Depot_longitude', 'Depot_pickup', 'Depot_delivery'])

    def on_add_new_depot_feature(self, featureId):
        layer = self.depot_layer
        feature = layer.getFeature(featureId)
        depot_latitude = feature.geometry().asPoint().y()
        depot_longitude = feature.geometry().asPoint().x()
        if layer.featureCount() == 1:
            depot_id = 1
        else:
            depot_id = int(layer.maximumValue(
                layer.fields().indexFromName('depot_id'))) + 1

        # FOR UPDATING THE ATTRIBUTE TABLE
        self.stopFile_field_dict = {}
        fields = layer.dataProvider().fields()
        for i in range(fields.count()):
            field = fields.field(i)
            self.stopFile_field_dict[field.name()] = i
        feature.setAttribute(self.stopFile_field_dict['depot_id'], depot_id)
        feature.setAttribute(
            self.stopFile_field_dict['depot_lat'], depot_latitude)
        feature.setAttribute(
            self.stopFile_field_dict['depot_lon'], depot_longitude)
        feature.setAttribute(
            self.stopFile_field_dict['pickup'], feature['pickup'])
        feature.setAttribute(
            self.stopFile_field_dict['delivery'], feature['delivery'])
        layer.updateFeature(feature)
        layer.updateExtents()
        # self.fill_table()

    def save_depot_data(self):
        # if self.depot_layer.isEditable():
        #     self.depot_layer.featureAdded.disconnect(
        #         self.on_add_new_depot_feature)
        #     self.depot_layer.commitChanges()
        #     self.dlg.table.clear()
        # save the location_df to csv
        # Location DataFrame file name
        location_file_name = 'location_data.csv'
        location_file_path, _ = QFileDialog.getSaveFileName(
            None, "Save Location DataFrame CSV", location_file_name, "CSV Files (*.csv)")
        if location_file_path:
            # Assuming location_df is your location DataFrame
            self.location_df.to_csv(location_file_path, index=False)
            print(f'Location DataFrame saved to {location_file_path}')
            QMessageBox.information(
                None, "Success", "Files has been extracted to output path.")

    def select_depot(self):
        if self.depot_layer == None:
            fields = QgsFields()
            fields.append(QgsField("depot_id", QVariant.String))
            fields.append(QgsField("depot_lat", QVariant.Double))
            fields.append(QgsField("depot_lon", QVariant.Double))
            fields.append(QgsField("pickup", QVariant.Int))
            fields.append(QgsField("delivery", QVariant.Int))

            crs = QgsCoordinateReferenceSystem('EPSG:4326')

            layer_name = "Depot_Layer"
            layer = QgsVectorLayer(
                f"Point?crs={crs.authid()}&field=depot_id:string&field=depot_lat:double&field=depot_lon:double&field=pickup:integer&field=delivery:integer",
                layer_name,
                "memory"
            )

            layer_provider = layer.dataProvider()
            layer_provider.addAttributes(fields)
            layer.updateFields()

            QgsProject.instance().addMapLayer(layer)
            self.depot_layer = layer

        if not self.depot_layer.isEditable():
            self.depot_layer.startEditing()
            iface.setActiveLayer(self.depot_layer)
            self.depot_layer.featureAdded.connect(
                self.on_add_new_depot_feature)

    def extract_csv(self):
        vehicle_capacity = [self.dlg.vehicle_capacity_le.text()]
        df = pd.DataFrame(list(zip(vehicle_capacity)),
                          columns=['vehicle capacity'])
        df.to_csv(
            "C:\\Users\\Rahul\\Downloads\\NDMVRP_Data\\Vehicle.csv", index=False)
        self.df.to_csv(
            "C:\\Users\\Rahul\\Downloads\\NDMVRP_Data\\Depot.csv", index=False)
        QMessageBox.information(
            None, "Success", "Files has been extracted to output path.")

    # ------------------------------------
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    ###### Custom Function For Buttons ######
    # $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    # ------------------------------------

    def assignIdsToButtonType(self):
        self.button_id_mapping = {}
        self.button_id_mapping[ADD_DEPOT] = self.vehicle_ids
        self.button_id_mapping[ADD_WAREHOUSE] = self.delivery_ids
        self.button_id_mapping[ADD_TRANSHIPMENT] = self.pickup_ids + \
            self.delivery_ids
        self.button_id_mapping[ADD_SIMULTANEOUS_NODES] = self.pickup_ids + \
            self.delivery_ids
        self.button_id_mapping[ADD_RELIEF_CENTER] = self.pickup_ids
        self.button_id_mapping[ADD_SPLIT_NODE] = self.pickup_ids + \
            self.delivery_ids

    # ###### add Vehicle Button ######

    def add_vehicle_type(self):
        # Method to handle the button click and show the dialog

        self.add_vehicle_dialog.show()
        # # Blocking call to wait for dialog result
        # result = self.add_vehicle_dialog.exec_()
        # if result == QDialog.Accepted:
        #     print("Dialog accepted")
        #     # Further actions after accepting the dialog if needed

    def addDataToVehicleTable(self):
        print("OK clicked")
        field_values = self.add_vehicle_dialog.get_field_values()
        # add data to existing vehicle df - self.vehicle_df

        print("addDataToVehicleTable() - field_values", field_values)
        size = len(self.vehicle_df)
        # add "Vehicle Type" to the field_values as 0th element
        field_values = {self.vehicle_fields[0]: f"VT{size+1}", **field_values}
        # self.vehicle_df = self.vehicle_df.append(field_values, ignore_index=True)
        # Concatenate the existing DataFrame with the new data
        self.vehicle_df = pd.concat(
            [self.vehicle_df, pd.DataFrame([field_values])], ignore_index=True)
        # Add data to table widget by clearing table using clear()
        self.dlg.vehicle_details.clear()
        # Reset column headers
        self.dlg.vehicle_details.setHorizontalHeaderLabels(self.vehicle_fields)

        # Add rows to table widget using data from vehicle_df
        # print the vehicle_df len
        print("addDataToVehicleTable() - vehicle_df len", len(self.vehicle_df))
        self.dlg.vehicle_details.setRowCount(len(self.vehicle_df))
        for row in range(len(self.vehicle_df)):
            for col in range(len(self.vehicle_df.columns)):
                self.dlg.vehicle_details.setItem(
                    row, col, QTableWidgetItem(str(self.vehicle_df.iloc[row, col])))

        # clear the fields and close the dialog
        self.add_vehicle_dialog.clear()
        # self.add_vehicle_dialog.close()
        # Close the dialog
        self.add_vehicle_dialog.accept()
        print("-----------------")

        # # Add data to table widget
        # row_position = self.dlg.vehicle_details.rowCount()
        # self.dlg.vehicle_details.insertRow(row_position)
        # # Set values in table widget
        # for col, (field, value) in enumerate(field_values.items()):
        #     self.dlg.vehicle_details.setItem(
        #         row_position, col, QTableWidgetItem(value))

    # ------- add Vehicle Button  END --------#

    # ###### add Pickup Cargo Button ######
    def add_pickup_cargo(self):
        self.add_pickup_dialog.show()

    def addDataToPickupTable(self):
        field_values = self.add_pickup_dialog.get_field_values()
        # add data to existing cargo_df - self.cargo_df
        if self.cargo_df is None:
            self.cargo_df = pd.DataFrame(
                columns=self.cargo_fields)
        print("addDataToPickupTable() - field_values", field_values)
        # add "pickup" to the field_values as 0th element
        size = len(self.cargo_df)
        # filter the cargo_df for pickup & get the size
        p_size = len(
            self.cargo_df[self.cargo_df['Pickup / Delivery'] == PICKUP])
        field_values = {self.cargo_fields[0]: PICKUP,
                        self.cargo_fields[1]: f"CC{p_size+1}P", **field_values}
        # self.cargo_df = self.cargo_df.append(field_values, ignore_index=True)
        self.cargo_df = pd.concat([self.cargo_df, pd.DataFrame(
            [field_values])], ignore_index=True)
        # Add data to table widget by clearing table using clear()
        self.dlg.cargo_details.clear()
        # Reset column headers
        self.dlg.cargo_details.setHorizontalHeaderLabels(self.cargo_fields)
        # Add rows to table widget using data from cargo_df
        # print the cargo_df len
        print("addDataToPickupTable() - cargo_df len", len(self.cargo_df))
        self.dlg.cargo_details.setRowCount(len(self.cargo_df))
        for row in range(len(self.cargo_df)):
            for col in range(len(self.cargo_df.columns)):
                self.dlg.cargo_details.setItem(
                    row, col, QTableWidgetItem(str(self.cargo_df.iloc[row, col])))
        # # Add data to table widget
        # row_position = self.dlg.cargo_details.rowCount()
        # self.dlg.cargo_details.insertRow(row_position)
        # # Set values in table widget
        # # set the value in the table - Pickup
        # self.dlg.cargo_details.setItem(
        #     row_position, 0, QTableWidgetItem("Pickup"))
        # for col, (field, value) in enumerate(field_values.items()):
        #     self.dlg.cargo_details.setItem(
        #         row_position, col+1, QTableWidgetItem(value))
        # # clear the fields
        self.add_pickup_dialog.clear()
        # close the dialog
        self.add_pickup_dialog.accept()
        print("-----------------")

    # ------- add Pickup Cargo Button  END --------#

    # ###### add Delivery Cargo Button ######
    def add_delivery_cargo(self):
        # Method to handle the button click and show the dialog
        self.add_delivery_dialog.show()

    def addDataToDeliveryTable(self):
        field_values = self.add_delivery_dialog.get_field_values()
        # add data to existing cargo_df - self.cargo_df
        if self.cargo_df is None:
            self.cargo_df = pd.DataFrame(
                columns=self.cargo_fields)
        print("addDataToDeliveryTable() - field_values", field_values)
        size = len(self.cargo_df)
        # add "delivery" to the field_values as 0th element
        # filter the cargo_df for delivery & get the size
        d_size = len(
            self.cargo_df[self.cargo_df['Pickup / Delivery'] == DELIVERY])
        field_values = {self.cargo_fields[0]: DELIVERY,
                        self.cargo_fields[1]: f"CC{d_size+1}D",  **field_values}
        # self.cargo_df = self.cargo_df.append(field_values, ignore_index=True)
        # self.vehicle_df = pd.concat([self.vehicle_df, pd.DataFrame([field_values])], ignore_index=True)
        self.cargo_df = pd.concat([self.cargo_df, pd.DataFrame(
            [field_values])], ignore_index=True)
        # Add data to table widget by clearing table using clear()
        self.dlg.cargo_details.clear()
        # Reset column headers
        self.dlg.cargo_details.setHorizontalHeaderLabels(self.cargo_fields)
        # Add rows to table widget using data from cargo_df
        # print the cargo_df len
        print("addDataToDeliveryTable() - cargo_df len", len(self.cargo_df))
        self.dlg.cargo_details.setRowCount(len(self.cargo_df))
        for row in range(len(self.cargo_df)):
            for col in range(len(self.cargo_df.columns)):
                self.dlg.cargo_details.setItem(
                    row, col, QTableWidgetItem(str(self.cargo_df.iloc[row, col])))
        # # Add data to table widget
        # row_position = self.dlg.cargo_details.rowCount()
        # self.dlg.cargo_details.insertRow(row_position)
        # # Set values in table widget
        # # set the value in the table - delivery
        # self.dlg.cargo_details.setItem(
        #     row_position, 0, QTableWidgetItem("Delivery"))
        # for col, (field, value) in enumerate(field_values.items()):
        #     self.dlg.cargo_details.setItem(
        #         row_position, col+1, QTableWidgetItem(value))

        # clear the fields
        self.add_delivery_dialog.clear()
        # close the dialog
        self.add_delivery_dialog.accept()
        print("-----------------")

    # ------- add Delivery Cargo Button  END --------#

    # ------- save_vehicle_cargo_data Button  START --------#
    def generate_matrix_data(self):
        print("generate_matrix_data()")
        # 1 create the dialog - matrix_dailog
        matrix_dialog = MatrixInputDialog(self.vehicle_df, self.cargo_df)
        result = matrix_dialog.exec_()
        if result == QDialog.Accepted:
            self.matrix_df = matrix_dialog.get_matrix_data()
            print("Matrix Data:")
            print(self.matrix_df)

        # Convert matrix_data to DataFrame
        # matrix_df = pd.DataFrame(matrix_data, columns=[
        #                          'Vehicle Type'] + [str(col) for col in self.cargo_df['Type']])
        # print("Matrix DataFrame:")
        # print(matrix_df)
        # Further processing or saving the matrix_df as needed

        # 2. modify Location Details table - add vehicle ids, pickup ids, delivery ids
        # table with name - depot_details
        self.depot_table_fields_new = [
            field for field in self.depot_table_fields]
        # add vehicle ids & append to depot_table_fields_new
        self.vehicle_ids = [id for id in self.vehicle_df['Vehicle Type']]
        self.depot_table_fields_new.extend(["Vertex Category"])
        self.depot_table_fields_new.extend(self.vehicle_ids)

        # add pickup ids by filtering pickup from cargo_df & append to depot_table_fields_new
        self.pickup_ids = [
            id for id in self.cargo_df[self.cargo_df['Pickup / Delivery'] == 'Pickup']['Types']]
        self.depot_table_fields_new.extend(self.pickup_ids)
        print("pickup_ids", self.pickup_ids)

        # add delivery ids by filtering delivery from cargo_df & append to depot_table_fields_new
        self.delivery_ids = [
            id for id in self.cargo_df[self.cargo_df['Pickup / Delivery'] == 'Delivery']['Types']]
        self.depot_table_fields_new.extend(self.delivery_ids)
        print("delivery_ids", self.delivery_ids)

        # set ids to buttons
        self.assignIdsToButtonType()

        # for row in range(len(self.cargo_df)):
        #     self.depot_table_fields_new.append(self.cargo_df.iloc[row]['Type'])
        print("self.depot_table_fields_new", self.depot_table_fields_new)
        # clear the depot_details table
        self.dlg.depot_details.clear()
        # set depot_details table column count
        self.dlg.depot_details.setColumnCount(len(self.depot_table_fields_new))
        self.dlg.depot_details.setHorizontalHeaderLabels(
            self.depot_table_fields_new)

    # ------- save_vehicle_cargo_data Button  END --------#

    # ###### add Depot Button ######

    def button_clicked_type(self, button_type):
        # Method to handle the add depot button click and show the dialog
        self.button_type = button_type
        self.dlg.showMinimized()
        self.get_lat_long_tool.canvasClicked.connect(self.clickHandler)
        self.canvas.setMapTool(self.get_lat_long_tool)

    def clickHandler(self, point):
        print("Clicked: ", point.x(), point.y())
        # check location_pickup_df
        if self.location_df is None:
            self.location_df = pd.DataFrame(
                columns=self.depot_table_fields_new)
        # set self latitude and longitude
        self.latitude = point.y()
        self.longitude = point.x()
        print("Latitude: ", self.latitude)
        print("Longitude: ", self.longitude)
        # if self.no == ADD_DEPOT:
        # show the dialog
        # based on button types provide list
        depot_dailog_fields = [
            "Description", "Multimodal Compatibility for Network_1", "Multimodal Compatibility for Network_2",
            "Multimodal Compatibility for Network_3", "Remarks/Comments"] + self.button_id_mapping[self.button_type]
        self.depot_dailog = FormDialogClass(depot_dailog_fields)
        self.depot_dailog.ok_button.clicked.connect(
            lambda: self.addDataToDepotTable(self.button_type))

        # set the dialog title based on button type
        self.depot_dailog.setWindowTitle(
            f"{button_type_text_mapping[self.button_type]} Information Input")
        # show the dialog
        self.depot_dailog.show()
        # Blocking call to wait for dialog result
        result = self.depot_dailog.exec_()
        if result == QDialog.Accepted:
            print("Dialog accepted")
            # Further actions after accepting the dialog if needed

        # close all
        self.dlg.showNormal()
        # free them
        self.canvas.unsetMapTool(self.get_lat_long_tool)
        self.get_lat_long_tool.canvasClicked.disconnect(self.clickHandler)

    def addNoDescriptionLatLong(self, size, description, button_type, field_values):
        # set No as 0th element & filter the location_df based on button_type & get size of the filtered df
        id_text = None
        vertex_category = None

        if button_type == ADD_DEPOT:
            id_text = "VD"
            vertex_category = "Vehicle Depot"
            size = len(self.location_df[self.location_df['Sl. No.'].str.startswith(
                id_text)])
        elif button_type == ADD_WAREHOUSE:
            id_text = "WH"
            vertex_category = "WareHouse"
            size = len(self.location_df[self.location_df['Sl. No.'].str.startswith(
                id_text)])
        elif button_type == ADD_TRANSHIPMENT:
            id_text = "TP"
            vertex_category = "Transhipment Port"
            size = len(self.location_df[self.location_df['Sl. No.'].str.startswith(
                id_text)])
        elif button_type == ADD_SIMULTANEOUS_NODES:
            id_text = "NM"
            vertex_category = "Simultaneous Node"
            size = len(self.location_df[self.location_df['Sl. No.'].str.startswith(
                id_text)])
        elif button_type == ADD_RELIEF_CENTER:
            id_text = "RC"
            vertex_category = "Relief Centre"
            size = len(self.location_df[self.location_df['Sl. No.'].str.startswith(
                id_text)])
        elif button_type == ADD_SPLIT_NODE:
            id_text = "NP"
            vertex_category = "Split Node"
            size = len(self.location_df[self.location_df['Sl. No.'].str.startswith(
                id_text)])
        row_data = {self.depot_table_fields_new[0]: f"{id_text}{size+1}"}
        # Add Vertex Category here
        row_data["Vertex Category"] = vertex_category
        # set Description as 1st element
        row_data[self.depot_table_fields_new[1]] = description
        # set latitute as 2nd element
        row_data[self.depot_table_fields_new[2]] = self.latitude
        # set longitude as 3rd element
        row_data[self.depot_table_fields_new[3]] = self.longitude
        # set multimodaliti datas as 4th,5th,6th and 7th element
        for field in ["Multimodal Compatibility for Network_1", "Multimodal Compatibility for Network_2",
                      "Multimodal Compatibility for Network_3", "Remarks/Comments"]:
            # Use get method to handle missing values
            row_data[field] = field_values.get(field, "")

        return row_data

    def addDataToDepotTable(self, button_type):
        # get the values from the dialog
        field_values = self.depot_dailog.get_field_values()
        # add data to existing location_df - self.location_df
        print("addDataToDepotTable() - field_values", field_values)
        size = len(self.location_df)
        # call addNoDescriptionLatLong() to add Sl. No., Description, Latitude, Longitude
        row_data = self.addNoDescriptionLatLong(
            size, field_values['Description'], self.button_type, field_values)
        # combine list
        combined_list = self.vehicle_ids + self.pickup_ids + self.delivery_ids
        # reset all ids to 0
        for ids in combined_list:
            row_data[ids] = 0

        # ---------- set row_data base on the button type --------------
        for field in self.button_id_mapping[button_type]:
            row_data[field] = field_values[field]

        # concat the row_data to location_df
        self.location_df = pd.concat(
            [self.location_df, pd.DataFrame([row_data])], ignore_index=True)

        # Add data to table widget by clearing table using clear()
        self.dlg.depot_details.clear()
        # Reset column headers
        self.dlg.depot_details.setHorizontalHeaderLabels(
            self.depot_table_fields_new + ["Vertex Category"])
        # Add rows to table widget using data from location_df
        # print the location_df len
        print("addDataToDepotTable() - location_df len", len(self.location_df))
        self.dlg.depot_details.setRowCount(len(self.location_df))
        for row in range(len(self.location_df)):
            for col in range(len(self.location_df.columns)):
                self.dlg.depot_details.setItem(
                    row, col, QTableWidgetItem(str(self.location_df.iloc[row, col])))
        # clear the fields
        self.depot_dailog.clear()
        # close the dialog
        self.depot_dailog.accept()
        self.depot_dailog = None

    # ------- add Depot Button  END --------#

    # ------- clear_location_table_data Button  START --------#
    def clear_location_table(self):
        self.location_df = None
        self.dlg.depot_details.clear()
        self.dlg.depot_details.setHorizontalHeaderLabels(
            self.depot_table_fields_new)
        self.dlg.depot_details.setRowCount(0)

    # ------- clear_location_table_data Button  END --------#

    # ------- save_all_data Button  START --------#

    def save_all_data(self):
        # Get the output folder path from the user
        output_folder_path = QFileDialog.getExistingDirectory(
            None, "Select Output Folder")
        if not output_folder_path:
            print("No output folder selected. Exiting.")
            return

        # Define file names and corresponding dataframes
        files_and_dfs = [
            ('0 Vehicles.csv', self.vehicle_df),
            ('0 Cargo.csv', self.cargo_df),
            ('1 Vehicle Cargo Compatibility and Loading Unloading Time.csv', self.matrix_df),
            ('1 Locations and PickUp Delivery details.csv', self.location_df)
        ]

        # Iterate over file names and dataframes and save them
        for file_name, df in files_and_dfs:
            file_path = os.path.join(output_folder_path, file_name)
            df.to_csv(file_path, index=False)
            print(f'DataFrame saved to {file_path}')

        QMessageBox.information(
            None, "Success", "Files have been extracted to output path.")

        ############## distance table code begins here###############

    def generate_travel_cost_tables(self):
        # convert or copy location_df to points_df with columns - point_id,latitude, longitude
        points_df = self.location_df.copy()
        points_df['No'] = points_df['Sl. No.']
        points_df = points_df[['No',
                               'Latitude', 'Longitude']]
        print("points_df")

        # Paths to road layers and output CSV files
        road_layers = ["Networks/Network_1.gpkg",
                       "Networks/Network_2.gpkg", "Networks/Network_3.gpkg"]
        output_csv_names = ["Distance_Matrix_for_Network_1.csv",
                            "Distance_Matrix_for_Network_2.csv", "Distance_Matrix_for_Network_3.csv"]
        output_layer_names = ["Distance Matrix for Network 1",
                              "Distance Matrix for Network 2", "Distance Matrix for Network 3"]

        # Get the output folder path from the user
        output_folder_path = QFileDialog.getExistingDirectory(
            None, "Select Output Folder")
        if not output_folder_path:
            print("No output folder selected. Exiting.")
            return

        points_df1 = self.location_df.copy()
        visualize_points(points_df1)

        # Iterate over road layers and calculate shortest paths for each
        for road_layer, output_csv_name, output_name in zip(road_layers, output_csv_names, output_layer_names):
            # Create the full output path
            output_csv_path = os.path.join(output_folder_path, output_csv_name)
            shortestpath(points_df, road_layer, output_csv_path, output_name)
            print(f'Travel Cost DataFrame saved to {output_csv_path}')

        QMessageBox.information(
            None, "Success", "Files have been extracted to output path.")

    

    def run_vrp(self):
        print("run_vrp() - function has started running")

        print("**************************************************************************************************")
        


        # time.sleep(1)
        # print("Slept 1 seconds in NDMVRP")


        #subprocess.run(["echo", "Hello, World!"], capture_output=True, text=True)
        

        # Run your subprocess
        #result = subprocess.run(["echo", "Hello, World!"])

        # Check the result
        #print(result)

        # Pause at the end
        #input("Press Enter to close...")



        #print("Current working directory: ",os.getcwd())
        current_dir = os.path.dirname(os.path.abspath(__file__))
        print(f"Current script directory: {current_dir}")
        psr_gip_heuristic_file_location = current_dir+"/PSR_GIP.py"

        



        # Get the Input CSV folder path from the user
        userDefined_INPUT_location_of_CSV = QFileDialog.getExistingDirectory(None, "Select the Folder Containing the input CSV Files")
        userDefined_INPUT_location_of_CSV += "/"
        # Writing the InPut directory path to the file
        file_path = "userDefined_INPUT_location_of_CSV.txt"
        with open(file_path, 'w') as file:
            file.write(userDefined_INPUT_location_of_CSV)
            print(f"userDefined_INPUT_location_of_CSV path '{userDefined_INPUT_location_of_CSV}' has been written to {file_path}")




        if not userDefined_INPUT_location_of_CSV:
            print("No Folder selected. Exiting.")
            return
        else:
            # If the Input Path is provided, we create the OutPut Directory and call the Heuristic as Subprocess

            OUTPUT_location = userDefined_INPUT_location_of_CSV + "OutPut/"
            file_path = "userDefined_OUTPUT_location.txt"
            with open(file_path, 'w') as file:
                file.write(OUTPUT_location)
                print(f"userDefined_OUTPUT_location path '{OUTPUT_location}' has been written to {file_path}")



            # Check if the OutPut directory exists
            if os.path.exists(OUTPUT_location) and os.path.isdir(OUTPUT_location):
                # Delete the directory
                try:
                    shutil.rmtree(OUTPUT_location)
                    print(f"The previously existing OutPut Directory '{OUTPUT_location}' (for some previous same input location) has been deleted successfully.")
                except Exception as e:
                    print(f"An error occurred while deleting the directory: {e}")
            else:
                print(f"Directory '{OUTPUT_location}' does not exist.")

            print("Creating the internal OutPut Directory for keeping Heuristic outputs...")
            os.makedirs(OUTPUT_location)

            # Calling the Heuristic as Subprocess
            subprocess.run(["python3", psr_gip_heuristic_file_location])
        

        print("Subprocess completed")
        



        # Some other values could also be provided here to see vizualizatioon of the other files like:  best_OUTPUT_file_location = OUTPUT_location + "AllRouteSUM_OutPut_2.xlsx"
        best_OUTPUT_file_location = OUTPUT_location + "MakeSPAN_OutPut_0.xlsx"







        merged_df = pd.read_excel(best_OUTPUT_file_location)


        # save the merged_df to csv
        #merged_df.to_csv(file_path, index=False)
        # print(f'Merged_df saved to {file_path}')

        # print(merged_df)
        #input("Wait for enter 2")


        # 2. run output breakdown for visualisation
        # location_df - 1 Locations and PickUp Delivery details.csv
        
        output_df = output_breakdown(merged_df, userDefined_INPUT_location_of_CSV)
        
        # # save the output_df to csv: Get the output folder path from the user
        # output_folder_path = QFileDialog.getExistingDirectory(None, "Select Output Folder")
        # if not output_folder_path:
        #     print("No output folder selected. Exiting.")
        #     return
        output_folder_path = userDefined_INPUT_location_of_CSV

        output_filename = "OutPut ordered with latitude and longitude.csv"
        output_file_path = os.path.join(output_folder_path, output_filename)
        output_df.to_csv(output_file_path, index=False)

        # 3. run route visualization
        datapoints_visualisation_road_layer(output_df)

        print("run_vrp() - function has finished running successfully")
